import ApiError from '../utils/apiError.util.js';

export const validateByModel = (model, options = {}) => {
  const { allowUnknown = false } = options;

  return async (req, res, next) => {
    try {
      const body = req.body || {};
      const method = req.method.toUpperCase();
      const isCreate = method === 'POST';

      const attributes = model.rawAttributes;
      const modelKeys = Object.keys(attributes);
      const bodyKeys = Object.keys(body);

      const allowedKeys = modelKeys.filter((key) => {
        const attr = attributes[key];
        return !attr._autoGenerated && key !== 'id' && key !== 'created_at' && key !== 'updated_at';
      });

      // Filter out unknown fields
      const unknownFields = bodyKeys.filter((key) => !modelKeys.includes(key));
      if (!allowUnknown && unknownFields.length > 0) {
        throw new ApiError(400, `Unknown fields: ${unknownFields.join(', ')}`);
      }

      // Required fields check for create
      if (isCreate) {
        for (const key of allowedKeys) {
          const attr = attributes[key];

          const isRequired =
            attr.allowNull === false &&
            attr.defaultValue === undefined &&
            !attr.autoIncrement &&
            !attr._autoGenerated;

          if (isRequired && (body[key] === null || body[key] === undefined)) {
            throw new ApiError(400, `${key} is required.`);
          }
        }
      }

      // Field-level validation
      for (const key of bodyKeys) {
        const value = body[key];
        const attr = attributes[key];

        if (!attr) continue; // skip unknown if allowUnknown=true

        // Unique check only on create
        if (isCreate && attr.unique && value != null) {
          const whereClause = { [key]: value };
          const existing = await model.scope('defaultScope').findOne({ where: whereClause });
          if (existing) {
            throw new ApiError(409, `${key} already exists.`);
          }
        }

        // Type validation
        if (value != null) {
          const typeName = attr.type.constructor.name;

          switch (typeName) {
            case 'STRING':
            case 'TEXT':
              if (typeof value !== 'string') throw new ApiError(400, `${key} must be a string.`);
              break;

            case 'INTEGER':
            case 'BIGINT':
              if (typeof value !== 'number' || !Number.isInteger(value)) {
                throw new ApiError(400, `${key} must be an integer.`);
              }
              break;

            case 'FLOAT':
            case 'DOUBLE':
            case 'DECIMAL':
              if (typeof value !== 'number') {
                throw new ApiError(400, `${key} must be a number.`);
              }
              break;

            case 'BOOLEAN':
              if (typeof value !== 'boolean') {
                throw new ApiError(400, `${key} must be a boolean.`);
              }
              break;

            case 'DATE':
            case 'DATEONLY':
              if (isNaN(Date.parse(value))) {
                throw new ApiError(400, `${key} must be a valid date.`);
              }
              break;

            case 'UUID':
              if (
                typeof value !== 'string' ||
                !/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                  value,
                )
              ) {
                throw new ApiError(400, `${key} must be a valid UUID.`);
              }
              break;

            case 'JSON':
            case 'JSONB':
              if (typeof value !== 'object' || Array.isArray(value)) {
                throw new ApiError(400, `${key} must be a valid JSON object.`);
              }
              break;

            default:
              // Skip unsupported or custom types silently
              break;
          }
        }
      }

      next();
    } catch (err) {
      console.error('Validation error:', err);
      next(err);
    }
  };
};
